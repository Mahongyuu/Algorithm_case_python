堆排序（Heap Sort）详解
1. 核心思想
堆排序利用 二叉堆（Binary Heap） 这种数据结构进行排序，核心思想包括：

构建最大堆：将无序数组调整为一个最大堆（父节点 ≥ 子节点），此时堆顶元素为全局最大值。

交换与调整：将堆顶元素（最大值）与数组末尾元素交换，缩小堆的范围（排除已排序部分），然后重新调整剩余部分为最大堆。

重复步骤：直到堆中只剩一个元素，完成排序。

关键点：

原地排序：不需要额外空间。

不稳定排序：相同值的元素可能交换顺序（如交换堆顶和末尾时）。

2. 算法步骤
步骤1：构建最大堆

从最后一个非叶子节点（索引 n//2 - 1）开始，从右至左、从下至上调用 heapify 调整堆。

步骤2：交换与调整

将堆顶元素（最大值）与当前堆的末尾元素交换。

排除末尾元素（已排序），对剩余堆重新调整（heapify）。

重复直到堆大小为1。

伪代码：

python
复制
def heap_sort(arr):
    n = len(arr)
    # 1. 构建最大堆
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
    # 2. 交换堆顶与末尾，并调整堆
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]  # 交换
        heapify(arr, i, 0)               # 调整剩余堆

def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2
    if left < n and arr[left] > arr[largest]:
        largest = left
    if right < n and arr[right] > arr[largest]:
        largest = right
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)  # 递归调整受影响子树
3. 算法案例
输入数组：[12, 11, 13, 5, 6, 7]
步骤解析：

初始建堆：

从非叶子节点 i=2（值 13）开始调整，无需交换。

调整 i=1（值 11），与左子节点 12 交换 → [12, 11, 13, 5, 6, 7]。

调整 i=0（值 12），与右子节点 13 交换 → [13, 11, 12, 5, 6, 7]。

最终最大堆：[13, 11, 12, 5, 6, 7]。

交换与调整：

交换堆顶 13 和末尾 7 → [7, 11, 12, 5, 6, 13]，调整前5个元素。

调整后堆：[12, 11, 7, 5, 6]。

重复交换堆顶 12 和末尾 6 → [6, 11, 7, 5, 12, 13]，调整前4个元素。

最终有序数组：[5, 6, 7, 11, 12, 13]。

4. 复杂度分析
时间复杂度：
建堆：O(n)（通过非叶子节点从下至上调整）。
每次调整堆：O(log n)，共 n−1次。
总复杂度：O(n log n)。
空间复杂度：O(1)（原地排序）。
不稳定排序：相同值的元素可能交换顺序。

5. 对比其他排序算法
算法	平均时间复杂度	空间复杂度	稳定性	特点
堆排序   O(nlogn)    O(1)        不稳定   适合内存受限场景
快速排序 O(nlogn)    O(logn)	    不稳定	平均最快，但最坏o(n^2)
归并排序 O(nlogn)    O(n)	    稳定	    需要额外空间
6. 应用场景
内存敏感环境：如嵌入式系统，需原地排序。

实时系统：保证最坏情况下仍为
O(nlogn)。

优先级队列：堆结构本身常用于动态数据排序（如任务调度）。

通过理解堆的调整过程（heapify）和分步交换，即可掌握堆排序的精髓！