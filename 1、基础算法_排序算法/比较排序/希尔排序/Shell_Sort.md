希尔排序 (Shell Sort)
核心思想
希尔排序是插入排序的改进版，通过分组插入排序逐步减少间隔（gap），使得数组逐渐趋于有序，最后进行一次标准插入排序。

核心优化点：通过较大的间隔先对远距离元素排序，减少后续插入排序的工作量。

别名：缩小增量排序（Diminishing Increment Sort）。

算法步骤
选择间隔序列（gap sequence）：确定一个递减的间隔序列（如 [n//2, n//4, ..., 1]）。

分组插入排序：对每个间隔 gap，将数组分成 gap 个子序列，对每个子序列进行插入排序。

缩小间隔：重复步骤 2，直到 gap = 1（此时相当于标准插入排序）。

最终插入排序：当 gap = 1 时，进行最后一次插入排序，确保数组完全有序。

算法案例
示例数组：[8, 3, 1, 4, 6, 7, 5, 2]
初始长度 n = 8，初始 gap = n//2 = 4

gap	分组方式	排序后数组
4	[8,6], [3,7], [1,5], [4,2]	[6, 3, 1, 2, 8, 7, 5, 4]
2	[6,1,8,5], [3,2,7,4]	[1, 2, 5, 3, 6, 4, 8, 7]
1	标准插入排序	[1, 2, 3, 4, 5, 6, 7, 8]
详细过程：

gap=4：

比较 8 和 6 → 交换 → [6, 3, 1, 4, 8, 7, 5, 2]

比较 3 和 7 → 不交换

比较 1 和 5 → 不交换

比较 4 和 2 → 交换 → [6, 3, 1, 2, 8, 7, 5, 4]

gap=2：

子序列 [6,1,8,5] → 排序后 [1,5,6,8]

子序列 [3,2,7,4] → 排序后 [2,3,4,7]

合并后 [1, 2, 5, 3, 6, 4, 8, 7]

gap=1：

标准插入排序 → 最终有序 [1, 2, 3, 4, 5, 6, 7, 8]

复杂度分析
情况	    时间复杂度	    空间复杂度	稳定性
最坏情况 O(n^2)             O(1)	    不稳定
平均情况 O(nlogn)~O(n^1.5)  O(1)	    不稳定
最好情况 O(nlogn)           O(1)	    不稳定
关键点：

时间复杂度取决于 gap 序列的选择
（ 如 n/2 序列最坏是 O(n^2)，而 Hibbard 序列可达 O(n^1.5)）。
不稳定：由于分组交换，可能改变相同元素的相对顺序。

Python 代码实现
def shell_sort(arr):
    n = len(arr)
    gap = n // 2  # 初始间隔

    while gap > 0:
        # 对每个子序列进行插入排序
        for i in range(gap, n):
            temp = arr[i]
            j = i
            # 插入排序逻辑
            while j >= gap and arr[j - gap] > temp:
                arr[j] = arr[j - gap]
                j -= gap
            arr[j] = temp
        gap //= 2  # 缩小间隔
    return arr

# 测试
arr = [8, 3, 1, 4, 6, 7, 5, 2]
print("排序前:", arr)
sorted_arr = shell_sort(arr)
print("排序后:", sorted_arr)
输出：

排序前: [8, 3, 1, 4, 6, 7, 5, 2]
排序后: [1, 2, 3, 4, 5, 6, 7, 8]
优化方向
更优的 gap 序列：如 Hibbard 序列 (1, 3, 7, 15...) 或 Sedgewick 序列，可提升效率。

结合插入排序优化：当 gap=1 时，可使用二分插入排序进一步优化。

希尔排序在中等规模数据中表现良好，且代码简单，适合嵌入式系统等场景！