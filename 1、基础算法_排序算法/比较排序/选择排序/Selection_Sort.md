选择排序 (Selection Sort)
核心思想
选择排序的核心思想是：

每次从未排序部分选出最小（或最大）元素，放到已排序部分的末尾。

逐步构建有序序列，每次选择一个最值元素，减少未排序部分的规模。

算法步骤
初始状态：整个数组视为未排序，已排序部分为空。

遍历未排序部分：从 i = 0 到 n-1，执行以下操作：

查找最小值：在未排序部分 [i, n-1] 中找到最小元素的索引 min_idx。

交换位置：将 arr[i] 与 arr[min_idx] 交换，将最小值放到已排序部分的末尾。

重复：直到所有元素排序完成。

算法案例
示例数组：[64, 25, 12, 22, 11]

步骤	操作	数组状态
初始	未排序：[64, 25, 12, 22, 11]	[64, 25, 12, 22, 11]
第1轮	找到最小值 11，与 64 交换	[11, 25, 12, 22, 64]
第2轮	找到最小值 12，与 25 交换	[11, 12, 25, 22, 64]
第3轮	找到最小值 22，与 25 交换	[11, 12, 22, 25, 64]
第4轮	找到最小值 25，已在正确位置	[11, 12, 22, 25, 64]
关键过程（第1轮）：

未排序部分 [64, 25, 12, 22, 11]，最小值 11（索引 4）。

交换 64 和 11 → [11, 25, 12, 22, 64]。

复杂度分析
情况	    时间复杂度	空间复杂度	稳定性
最坏情况 O(n^2)       O(1)	    不稳定
平均情况 O(n^2)       O(1)	    不稳定
最好情况 O(n^2)       O(1)	    不稳定

特点：

不稳定排序：如 [5, 5, 2]，第一个 5 会被交换到 2 后面。

原地排序：无需额外空间。

交换次数少：最多交换 n-1 次（优于冒泡排序）。

Python 代码实现
基础版本
def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_idx = i  # 假设当前元素是最小的
        for j in range(i + 1, n):  # 在未排序部分找最小值
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]  # 交换
    return arr

# 测试
arr = [64, 25, 12, 22, 11]
print("排序前:", arr)
sorted_arr = selection_sort(arr.copy())
print("排序后:", sorted_arr)
输出：

排序前: [64, 25, 12, 22, 11]
排序后: [11, 12, 22, 25, 64]

优化版本（同时找最小和最大值）
def selection_sort_optimized(arr):
    n = len(arr)
    for i in range(n // 2):
        min_idx, max_idx = i, i
        for j in range(i, n - i):
            if arr[j] < arr[min_idx]:
                min_idx = j
            if arr[j] > arr[max_idx]:
                max_idx = j
        # 将最小值放到前面
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
        # 如果最大值被交换过，修正索引
        if max_idx == i:
            max_idx = min_idx
        # 将最大值放到后面
        arr[n - i - 1], arr[max_idx] = arr[max_idx], arr[n - i - 1]
    return arr

适用场景
小规模数据：简单且交换次数少。

对内存有限制：原地排序，空间复杂度 O(1)。

不要求稳定性：相同元素可能交换顺序。

选择排序是理解排序算法的经典案例，但实际应用中效率较低，通常被更高效的算法（如快速排序）替代。