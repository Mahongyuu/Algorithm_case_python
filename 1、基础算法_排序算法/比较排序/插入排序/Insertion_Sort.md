插入排序 (Insertion Sort)
核心思想
插入排序是一种简单直观的排序算法，其核心思想是：

将数组分为“已排序”和“未排序”两部分，逐个将未排序部分的元素插入到已排序部分的正确位置。

类似扑克牌排序：每次摸一张新牌，插入到手中已排序牌的正确位置。

算法步骤
初始状态：第一个元素默认已排序。

遍历未排序部分：从第二个元素开始，依次取出当前元素。

插入到已排序序列：

从后向前扫描已排序部分，找到合适的位置。

如果当前元素比已排序元素小，则后移已排序元素，腾出插入位置。

插入元素：将当前元素放入正确位置。

重复：直到所有元素排序完成。

算法案例
示例数组：[5, 2, 4, 6, 1, 3]

步骤	操作	数组状态
初始	已排序区间 [5]	[5, 2, 4, 6, 1, 3]
第1轮	插入 2 → [2, 5]	[2, 5, 4, 6, 1, 3]
第2轮	插入 4 → [2, 4, 5]	[2, 4, 5, 6, 1, 3]
第3轮	插入 6 → [2, 4, 5, 6]	[2, 4, 5, 6, 1, 3]
第4轮	插入 1 → [1, 2, 4, 5, 6]	[1, 2, 4, 5, 6, 3]
第5轮	插入 3 → [1, 2, 3, 4, 5, 6]	[1, 2, 3, 4, 5, 6]
关键过程（以插入 1 为例）：

当前未排序元素 1，已排序部分 [2, 4, 5, 6]。

从后向前比较：

1 < 6 → 后移 6 → [2, 4, 5, 6, 6]

1 < 5 → 后移 5 → [2, 4, 5, 5, 6]

1 < 4 → 后移 4 → [2, 4, 4, 5, 6]

1 < 2 → 后移 2 → [2, 2, 4, 5, 6]

插入 1 到首位 → [1, 2, 4, 5, 6]

复杂度分析
情况	            时间复杂度	空间复杂度	稳定性
最坏情况（逆序） O(n^2)        O(1)	    稳定
平均情况        O(n^2)        O(1)	    稳定
最好情况（有序） O(n)          O(1)	    稳定

特点：

稳定排序：相同元素不会交换位置。

原地排序：无需额外空间。

小规模数据高效：在近乎有序的数组中接近 O(n)。

Python 代码实现
基础版本
def insertion_sort(arr):
    for i in range(1, len(arr)):  # 从第二个元素开始
        key = arr[i]  # 当前待插入元素
        j = i - 1     # 已排序部分的最后一个索引
        # 从后向前比较并后移
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key  # 插入到正确位置
    return arr

# 测试
arr = [5, 2, 4, 6, 1, 3]
print("排序前:", arr)
sorted_arr = insertion_sort(arr.copy())
print("排序后:", sorted_arr)
输出：

排序前: [5, 2, 4, 6, 1, 3]
排序后: [1, 2, 3, 4, 5, 6]

优化版本（二分查找插入位置）
def binary_insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        # 使用二分查找找到插入位置
        left, right = 0, i - 1
        while left <= right:
            mid = (left + right) // 2
            if key < arr[mid]:
                right = mid - 1
            else:
                left = mid + 1
        # 后移元素并插入
        arr[left+1:i+1] = arr[left:i]
        arr[left] = key
    return arr

适用场景
小规模数据：在 n≤100 时效率较高。

近乎有序数组：如日志按时间近乎有序时，接近 O(n)。

其他算法的子过程：如 Timsort 和希尔排序中用到插入排序。